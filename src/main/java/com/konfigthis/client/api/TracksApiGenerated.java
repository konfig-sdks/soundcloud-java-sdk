/*
 * SoundCloud Public API Specification
 * Discover and play over 320 million music tracks. Join the world’s largest online community of artists, bands, DJs, and audio creators.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.api;

import com.konfigthis.client.ApiCallback;
import com.konfigthis.client.ApiClient;
import com.konfigthis.client.ApiException;
import com.konfigthis.client.ApiResponse;
import com.konfigthis.client.Configuration;
import com.konfigthis.client.Pair;
import com.konfigthis.client.ProgressRequestBody;
import com.konfigthis.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.konfigthis.client.model.Comment;
import com.konfigthis.client.model.Comments;
import java.io.File;
import com.konfigthis.client.model.Streams;
import com.konfigthis.client.model.Track;
import com.konfigthis.client.model.TrackDataRequest;
import com.konfigthis.client.model.TrackMetadataRequest;
import com.konfigthis.client.model.TrackMetadataRequestTrack;
import com.konfigthis.client.model.TracksCreateCommentRequest;
import com.konfigthis.client.model.TracksCreateCommentRequestComment;
import com.konfigthis.client.model.TracksUploadNewTrackRequest;
import com.konfigthis.client.model.TracksUploadNewTrackRequest1;
import com.konfigthis.client.model.Users;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class TracksApiGenerated {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public TracksApiGenerated() throws IllegalArgumentException {
        this(Configuration.getDefaultApiClient());
    }

    public TracksApiGenerated(ApiClient apiClient) throws IllegalArgumentException {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call createCommentCall(Integer trackId, TracksCreateCommentRequest tracksCreateCommentRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = tracksCreateCommentRequest;

        // create path and map variables
        String localVarPath = "/tracks/{track_id}/comments"
            .replace("{" + "track_id" + "}", localVarApiClient.escapeString(trackId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json; charset=utf-8",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json; charset=utf-8"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "AuthHeader" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createCommentValidateBeforeCall(Integer trackId, TracksCreateCommentRequest tracksCreateCommentRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'trackId' is set
        if (trackId == null) {
            throw new ApiException("Missing the required parameter 'trackId' when calling createComment(Async)");
        }

        // verify the required parameter 'tracksCreateCommentRequest' is set
        if (tracksCreateCommentRequest == null) {
            throw new ApiException("Missing the required parameter 'tracksCreateCommentRequest' when calling createComment(Async)");
        }

        return createCommentCall(trackId, tracksCreateCommentRequest, _callback);

    }


    private ApiResponse<Comment> createCommentWithHttpInfo(Integer trackId, TracksCreateCommentRequest tracksCreateCommentRequest) throws ApiException {
        okhttp3.Call localVarCall = createCommentValidateBeforeCall(trackId, tracksCreateCommentRequest, null);
        Type localVarReturnType = new TypeToken<Comment>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call createCommentAsync(Integer trackId, TracksCreateCommentRequest tracksCreateCommentRequest, final ApiCallback<Comment> _callback) throws ApiException {

        okhttp3.Call localVarCall = createCommentValidateBeforeCall(trackId, tracksCreateCommentRequest, _callback);
        Type localVarReturnType = new TypeToken<Comment>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class CreateCommentRequestBuilder {
        private final Integer trackId;
        private TracksCreateCommentRequestComment comment;

        private CreateCommentRequestBuilder(Integer trackId) {
            this.trackId = trackId;
        }

        /**
         * Set comment
         * @param comment  (optional)
         * @return CreateCommentRequestBuilder
         */
        public CreateCommentRequestBuilder comment(TracksCreateCommentRequestComment comment) {
            this.comment = comment;
            return this;
        }
        
        /**
         * Build call for createComment
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            TracksCreateCommentRequest tracksCreateCommentRequest = buildBodyParams();
            return createCommentCall(trackId, tracksCreateCommentRequest, _callback);
        }

        private TracksCreateCommentRequest buildBodyParams() {
            TracksCreateCommentRequest tracksCreateCommentRequest = new TracksCreateCommentRequest();
            tracksCreateCommentRequest.comment(this.comment);
            return tracksCreateCommentRequest;
        }

        /**
         * Execute createComment request
         * @return Comment
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public Comment execute() throws ApiException {
            TracksCreateCommentRequest tracksCreateCommentRequest = buildBodyParams();
            ApiResponse<Comment> localVarResp = createCommentWithHttpInfo(trackId, tracksCreateCommentRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute createComment request with HTTP info returned
         * @return ApiResponse&lt;Comment&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Comment> executeWithHttpInfo() throws ApiException {
            TracksCreateCommentRequest tracksCreateCommentRequest = buildBodyParams();
            return createCommentWithHttpInfo(trackId, tracksCreateCommentRequest);
        }

        /**
         * Execute createComment request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Comment> _callback) throws ApiException {
            TracksCreateCommentRequest tracksCreateCommentRequest = buildBodyParams();
            return createCommentAsync(trackId, tracksCreateCommentRequest, _callback);
        }
    }

    /**
     * Returns the newly created comment on success
     * 
     * @param trackId SoundCloud Track id (required)
     * @param tracksCreateCommentRequest Body of a comment  (required)
     * @return CreateCommentRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public CreateCommentRequestBuilder createComment(Integer trackId) throws IllegalArgumentException {
        if (trackId == null) throw new IllegalArgumentException("\"trackId\" is required but got null");
        return new CreateCommentRequestBuilder(trackId);
    }
    private okhttp3.Call deleteTrackCall(Integer trackId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/tracks/{track_id}"
            .replace("{" + "track_id" + "}", localVarApiClient.escapeString(trackId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "AuthHeader" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteTrackValidateBeforeCall(Integer trackId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'trackId' is set
        if (trackId == null) {
            throw new ApiException("Missing the required parameter 'trackId' when calling deleteTrack(Async)");
        }

        return deleteTrackCall(trackId, _callback);

    }


    private ApiResponse<Void> deleteTrackWithHttpInfo(Integer trackId) throws ApiException {
        okhttp3.Call localVarCall = deleteTrackValidateBeforeCall(trackId, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call deleteTrackAsync(Integer trackId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteTrackValidateBeforeCall(trackId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class DeleteTrackRequestBuilder {
        private final Integer trackId;

        private DeleteTrackRequestBuilder(Integer trackId) {
            this.trackId = trackId;
        }

        /**
         * Build call for deleteTrack
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return deleteTrackCall(trackId, _callback);
        }


        /**
         * Execute deleteTrack request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            deleteTrackWithHttpInfo(trackId);
        }

        /**
         * Execute deleteTrack request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            return deleteTrackWithHttpInfo(trackId);
        }

        /**
         * Execute deleteTrack request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            return deleteTrackAsync(trackId, _callback);
        }
    }

    /**
     * Deletes a track.
     * 
     * @param trackId SoundCloud Track id (required)
     * @return DeleteTrackRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public DeleteTrackRequestBuilder deleteTrack(Integer trackId) throws IllegalArgumentException {
        if (trackId == null) throw new IllegalArgumentException("\"trackId\" is required but got null");
        return new DeleteTrackRequestBuilder(trackId);
    }
    private okhttp3.Call getByIdCall(Integer trackId, String secretToken, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/tracks/{track_id}"
            .replace("{" + "track_id" + "}", localVarApiClient.escapeString(trackId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (secretToken != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("secret_token", secretToken));
        }

        final String[] localVarAccepts = {
            "application/json; charset=utf-8",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "AuthHeader" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getByIdValidateBeforeCall(Integer trackId, String secretToken, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'trackId' is set
        if (trackId == null) {
            throw new ApiException("Missing the required parameter 'trackId' when calling getById(Async)");
        }

        return getByIdCall(trackId, secretToken, _callback);

    }


    private ApiResponse<Track> getByIdWithHttpInfo(Integer trackId, String secretToken) throws ApiException {
        okhttp3.Call localVarCall = getByIdValidateBeforeCall(trackId, secretToken, null);
        Type localVarReturnType = new TypeToken<Track>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getByIdAsync(Integer trackId, String secretToken, final ApiCallback<Track> _callback) throws ApiException {

        okhttp3.Call localVarCall = getByIdValidateBeforeCall(trackId, secretToken, _callback);
        Type localVarReturnType = new TypeToken<Track>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetByIdRequestBuilder {
        private final Integer trackId;
        private String secretToken;

        private GetByIdRequestBuilder(Integer trackId) {
            this.trackId = trackId;
        }

        /**
         * Set secretToken
         * @param secretToken A secret token to fetch private playlists/tracks (optional)
         * @return GetByIdRequestBuilder
         */
        public GetByIdRequestBuilder secretToken(String secretToken) {
            this.secretToken = secretToken;
            return this;
        }
        
        /**
         * Build call for getById
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getByIdCall(trackId, secretToken, _callback);
        }


        /**
         * Execute getById request
         * @return Track
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public Track execute() throws ApiException {
            ApiResponse<Track> localVarResp = getByIdWithHttpInfo(trackId, secretToken);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getById request with HTTP info returned
         * @return ApiResponse&lt;Track&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Track> executeWithHttpInfo() throws ApiException {
            return getByIdWithHttpInfo(trackId, secretToken);
        }

        /**
         * Execute getById request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Track> _callback) throws ApiException {
            return getByIdAsync(trackId, secretToken, _callback);
        }
    }

    /**
     * Returns a track.
     * 
     * @param trackId SoundCloud Track id (required)
     * @return GetByIdRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public GetByIdRequestBuilder getById(Integer trackId) throws IllegalArgumentException {
        if (trackId == null) throw new IllegalArgumentException("\"trackId\" is required but got null");
        return new GetByIdRequestBuilder(trackId);
    }
    private okhttp3.Call getCommentsCall(Integer trackId, Integer limit, Integer offset, Boolean linkedPartitioning, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/tracks/{track_id}/comments"
            .replace("{" + "track_id" + "}", localVarApiClient.escapeString(trackId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (linkedPartitioning != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("linked_partitioning", linkedPartitioning));
        }

        final String[] localVarAccepts = {
            "application/json; charset=utf-8",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "AuthHeader" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getCommentsValidateBeforeCall(Integer trackId, Integer limit, Integer offset, Boolean linkedPartitioning, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'trackId' is set
        if (trackId == null) {
            throw new ApiException("Missing the required parameter 'trackId' when calling getComments(Async)");
        }

        return getCommentsCall(trackId, limit, offset, linkedPartitioning, _callback);

    }


    private ApiResponse<Comments> getCommentsWithHttpInfo(Integer trackId, Integer limit, Integer offset, Boolean linkedPartitioning) throws ApiException {
        okhttp3.Call localVarCall = getCommentsValidateBeforeCall(trackId, limit, offset, linkedPartitioning, null);
        Type localVarReturnType = new TypeToken<Comments>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getCommentsAsync(Integer trackId, Integer limit, Integer offset, Boolean linkedPartitioning, final ApiCallback<Comments> _callback) throws ApiException {

        okhttp3.Call localVarCall = getCommentsValidateBeforeCall(trackId, limit, offset, linkedPartitioning, _callback);
        Type localVarReturnType = new TypeToken<Comments>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetCommentsRequestBuilder {
        private final Integer trackId;
        private Integer limit;
        private Integer offset;
        private Boolean linkedPartitioning;

        private GetCommentsRequestBuilder(Integer trackId) {
            this.trackId = trackId;
        }

        /**
         * Set limit
         * @param limit Number of results to return in the collection. (optional, default to 50)
         * @return GetCommentsRequestBuilder
         */
        public GetCommentsRequestBuilder limit(Integer limit) {
            this.limit = limit;
            return this;
        }
        
        /**
         * Set offset
         * @param offset Offset of first result. Deprecated, use &#x60;linked_partitioning&#x60; instead. (optional, default to 0)
         * @return GetCommentsRequestBuilder
         */
        public GetCommentsRequestBuilder offset(Integer offset) {
            this.offset = offset;
            return this;
        }
        
        /**
         * Set linkedPartitioning
         * @param linkedPartitioning Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used) (optional)
         * @return GetCommentsRequestBuilder
         */
        public GetCommentsRequestBuilder linkedPartitioning(Boolean linkedPartitioning) {
            this.linkedPartitioning = linkedPartitioning;
            return this;
        }
        
        /**
         * Build call for getComments
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getCommentsCall(trackId, limit, offset, linkedPartitioning, _callback);
        }


        /**
         * Execute getComments request
         * @return Comments
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public Comments execute() throws ApiException {
            ApiResponse<Comments> localVarResp = getCommentsWithHttpInfo(trackId, limit, offset, linkedPartitioning);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getComments request with HTTP info returned
         * @return ApiResponse&lt;Comments&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Comments> executeWithHttpInfo() throws ApiException {
            return getCommentsWithHttpInfo(trackId, limit, offset, linkedPartitioning);
        }

        /**
         * Execute getComments request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Comments> _callback) throws ApiException {
            return getCommentsAsync(trackId, limit, offset, linkedPartitioning, _callback);
        }
    }

    /**
     * Returns the comments posted on the track(track_id).
     * 
     * @param trackId SoundCloud Track id (required)
     * @return GetCommentsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public GetCommentsRequestBuilder getComments(Integer trackId) throws IllegalArgumentException {
        if (trackId == null) throw new IllegalArgumentException("\"trackId\" is required but got null");
        return new GetCommentsRequestBuilder(trackId);
    }
    private okhttp3.Call getFavoritersCall(Integer trackId, Integer limit, Boolean linkedPartitioning, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/tracks/{track_id}/favoriters"
            .replace("{" + "track_id" + "}", localVarApiClient.escapeString(trackId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (linkedPartitioning != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("linked_partitioning", linkedPartitioning));
        }

        final String[] localVarAccepts = {
            "application/json; charset=utf-8",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "AuthHeader" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getFavoritersValidateBeforeCall(Integer trackId, Integer limit, Boolean linkedPartitioning, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'trackId' is set
        if (trackId == null) {
            throw new ApiException("Missing the required parameter 'trackId' when calling getFavoriters(Async)");
        }

        return getFavoritersCall(trackId, limit, linkedPartitioning, _callback);

    }


    private ApiResponse<Users> getFavoritersWithHttpInfo(Integer trackId, Integer limit, Boolean linkedPartitioning) throws ApiException {
        okhttp3.Call localVarCall = getFavoritersValidateBeforeCall(trackId, limit, linkedPartitioning, null);
        Type localVarReturnType = new TypeToken<Users>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getFavoritersAsync(Integer trackId, Integer limit, Boolean linkedPartitioning, final ApiCallback<Users> _callback) throws ApiException {

        okhttp3.Call localVarCall = getFavoritersValidateBeforeCall(trackId, limit, linkedPartitioning, _callback);
        Type localVarReturnType = new TypeToken<Users>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetFavoritersRequestBuilder {
        private final Integer trackId;
        private Integer limit;
        private Boolean linkedPartitioning;

        private GetFavoritersRequestBuilder(Integer trackId) {
            this.trackId = trackId;
        }

        /**
         * Set limit
         * @param limit Number of results to return in the collection. (optional, default to 50)
         * @return GetFavoritersRequestBuilder
         */
        public GetFavoritersRequestBuilder limit(Integer limit) {
            this.limit = limit;
            return this;
        }
        
        /**
         * Set linkedPartitioning
         * @param linkedPartitioning Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used) (optional)
         * @return GetFavoritersRequestBuilder
         */
        public GetFavoritersRequestBuilder linkedPartitioning(Boolean linkedPartitioning) {
            this.linkedPartitioning = linkedPartitioning;
            return this;
        }
        
        /**
         * Build call for getFavoriters
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getFavoritersCall(trackId, limit, linkedPartitioning, _callback);
        }


        /**
         * Execute getFavoriters request
         * @return Users
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public Users execute() throws ApiException {
            ApiResponse<Users> localVarResp = getFavoritersWithHttpInfo(trackId, limit, linkedPartitioning);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getFavoriters request with HTTP info returned
         * @return ApiResponse&lt;Users&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Users> executeWithHttpInfo() throws ApiException {
            return getFavoritersWithHttpInfo(trackId, limit, linkedPartitioning);
        }

        /**
         * Execute getFavoriters request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Users> _callback) throws ApiException {
            return getFavoritersAsync(trackId, limit, linkedPartitioning, _callback);
        }
    }

    /**
     * Returns a list of users who have favorited or liked the track.
     * 
     * @param trackId SoundCloud Track id (required)
     * @return GetFavoritersRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public GetFavoritersRequestBuilder getFavoriters(Integer trackId) throws IllegalArgumentException {
        if (trackId == null) throw new IllegalArgumentException("\"trackId\" is required but got null");
        return new GetFavoritersRequestBuilder(trackId);
    }
    private okhttp3.Call getRelatedTracksCall(Integer trackId, List<String> access, Integer limit, Integer offset, Boolean linkedPartitioning, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/tracks/{track_id}/related"
            .replace("{" + "track_id" + "}", localVarApiClient.escapeString(trackId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (access != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "access", access));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (linkedPartitioning != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("linked_partitioning", linkedPartitioning));
        }

        final String[] localVarAccepts = {
            "application/json; charset=utf-8",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "AuthHeader" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getRelatedTracksValidateBeforeCall(Integer trackId, List<String> access, Integer limit, Integer offset, Boolean linkedPartitioning, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'trackId' is set
        if (trackId == null) {
            throw new ApiException("Missing the required parameter 'trackId' when calling getRelatedTracks(Async)");
        }

        return getRelatedTracksCall(trackId, access, limit, offset, linkedPartitioning, _callback);

    }


    private ApiResponse<Object> getRelatedTracksWithHttpInfo(Integer trackId, List<String> access, Integer limit, Integer offset, Boolean linkedPartitioning) throws ApiException {
        okhttp3.Call localVarCall = getRelatedTracksValidateBeforeCall(trackId, access, limit, offset, linkedPartitioning, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getRelatedTracksAsync(Integer trackId, List<String> access, Integer limit, Integer offset, Boolean linkedPartitioning, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = getRelatedTracksValidateBeforeCall(trackId, access, limit, offset, linkedPartitioning, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetRelatedTracksRequestBuilder {
        private final Integer trackId;
        private List<String> access;
        private Integer limit;
        private Integer offset;
        private Boolean linkedPartitioning;

        private GetRelatedTracksRequestBuilder(Integer trackId) {
            this.trackId = trackId;
        }

        /**
         * Set access
         * @param access Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you&#39;d like to see all possible tracks. See &#x60;Track#access&#x60; schema for more details.  (optional)
         * @return GetRelatedTracksRequestBuilder
         */
        public GetRelatedTracksRequestBuilder access(List<String> access) {
            this.access = access;
            return this;
        }
        
        /**
         * Set limit
         * @param limit Number of results to return in the collection. (optional, default to 50)
         * @return GetRelatedTracksRequestBuilder
         */
        public GetRelatedTracksRequestBuilder limit(Integer limit) {
            this.limit = limit;
            return this;
        }
        
        /**
         * Set offset
         * @param offset Offset of first result. Deprecated, use &#x60;linked_partitioning&#x60; instead. (optional, default to 0)
         * @return GetRelatedTracksRequestBuilder
         */
        public GetRelatedTracksRequestBuilder offset(Integer offset) {
            this.offset = offset;
            return this;
        }
        
        /**
         * Set linkedPartitioning
         * @param linkedPartitioning Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used) (optional)
         * @return GetRelatedTracksRequestBuilder
         */
        public GetRelatedTracksRequestBuilder linkedPartitioning(Boolean linkedPartitioning) {
            this.linkedPartitioning = linkedPartitioning;
            return this;
        }
        
        /**
         * Build call for getRelatedTracks
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getRelatedTracksCall(trackId, access, limit, offset, linkedPartitioning, _callback);
        }


        /**
         * Execute getRelatedTracks request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            ApiResponse<Object> localVarResp = getRelatedTracksWithHttpInfo(trackId, access, limit, offset, linkedPartitioning);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getRelatedTracks request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            return getRelatedTracksWithHttpInfo(trackId, access, limit, offset, linkedPartitioning);
        }

        /**
         * Execute getRelatedTracks request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            return getRelatedTracksAsync(trackId, access, limit, offset, linkedPartitioning, _callback);
        }
    }

    /**
     * Returns all related tracks of track on SoundCloud.
     * 
     * @param trackId SoundCloud Track id (required)
     * @return GetRelatedTracksRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public GetRelatedTracksRequestBuilder getRelatedTracks(Integer trackId) throws IllegalArgumentException {
        if (trackId == null) throw new IllegalArgumentException("\"trackId\" is required but got null");
        return new GetRelatedTracksRequestBuilder(trackId);
    }
    private okhttp3.Call getStreamableUrlsCall(Integer trackId, String secretToken, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/tracks/{track_id}/streams"
            .replace("{" + "track_id" + "}", localVarApiClient.escapeString(trackId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (secretToken != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("secret_token", secretToken));
        }

        final String[] localVarAccepts = {
            "application/json; charset=utf-8",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "AuthHeader" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getStreamableUrlsValidateBeforeCall(Integer trackId, String secretToken, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'trackId' is set
        if (trackId == null) {
            throw new ApiException("Missing the required parameter 'trackId' when calling getStreamableUrls(Async)");
        }

        return getStreamableUrlsCall(trackId, secretToken, _callback);

    }


    private ApiResponse<Streams> getStreamableUrlsWithHttpInfo(Integer trackId, String secretToken) throws ApiException {
        okhttp3.Call localVarCall = getStreamableUrlsValidateBeforeCall(trackId, secretToken, null);
        Type localVarReturnType = new TypeToken<Streams>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getStreamableUrlsAsync(Integer trackId, String secretToken, final ApiCallback<Streams> _callback) throws ApiException {

        okhttp3.Call localVarCall = getStreamableUrlsValidateBeforeCall(trackId, secretToken, _callback);
        Type localVarReturnType = new TypeToken<Streams>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetStreamableUrlsRequestBuilder {
        private final Integer trackId;
        private String secretToken;

        private GetStreamableUrlsRequestBuilder(Integer trackId) {
            this.trackId = trackId;
        }

        /**
         * Set secretToken
         * @param secretToken A secret token to fetch private playlists/tracks (optional)
         * @return GetStreamableUrlsRequestBuilder
         */
        public GetStreamableUrlsRequestBuilder secretToken(String secretToken) {
            this.secretToken = secretToken;
            return this;
        }
        
        /**
         * Build call for getStreamableUrls
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getStreamableUrlsCall(trackId, secretToken, _callback);
        }


        /**
         * Execute getStreamableUrls request
         * @return Streams
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public Streams execute() throws ApiException {
            ApiResponse<Streams> localVarResp = getStreamableUrlsWithHttpInfo(trackId, secretToken);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getStreamableUrls request with HTTP info returned
         * @return ApiResponse&lt;Streams&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Streams> executeWithHttpInfo() throws ApiException {
            return getStreamableUrlsWithHttpInfo(trackId, secretToken);
        }

        /**
         * Execute getStreamableUrls request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Streams> _callback) throws ApiException {
            return getStreamableUrlsAsync(trackId, secretToken, _callback);
        }
    }

    /**
     * Returns a track&#39;s streamable URLs
     * 
     * @param trackId SoundCloud Track id (required)
     * @return GetStreamableUrlsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public GetStreamableUrlsRequestBuilder getStreamableUrls(Integer trackId) throws IllegalArgumentException {
        if (trackId == null) throw new IllegalArgumentException("\"trackId\" is required but got null");
        return new GetStreamableUrlsRequestBuilder(trackId);
    }
    private okhttp3.Call listRepostersCall(Integer trackId, Integer limit, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/tracks/{track_id}/reposters"
            .replace("{" + "track_id" + "}", localVarApiClient.escapeString(trackId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        final String[] localVarAccepts = {
            "application/json; charset=utf-8",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "AuthHeader" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listRepostersValidateBeforeCall(Integer trackId, Integer limit, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'trackId' is set
        if (trackId == null) {
            throw new ApiException("Missing the required parameter 'trackId' when calling listReposters(Async)");
        }

        return listRepostersCall(trackId, limit, _callback);

    }


    private ApiResponse<Users> listRepostersWithHttpInfo(Integer trackId, Integer limit) throws ApiException {
        okhttp3.Call localVarCall = listRepostersValidateBeforeCall(trackId, limit, null);
        Type localVarReturnType = new TypeToken<Users>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listRepostersAsync(Integer trackId, Integer limit, final ApiCallback<Users> _callback) throws ApiException {

        okhttp3.Call localVarCall = listRepostersValidateBeforeCall(trackId, limit, _callback);
        Type localVarReturnType = new TypeToken<Users>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ListRepostersRequestBuilder {
        private final Integer trackId;
        private Integer limit;

        private ListRepostersRequestBuilder(Integer trackId) {
            this.trackId = trackId;
        }

        /**
         * Set limit
         * @param limit Number of results to return in the collection. (optional, default to 50)
         * @return ListRepostersRequestBuilder
         */
        public ListRepostersRequestBuilder limit(Integer limit) {
            this.limit = limit;
            return this;
        }
        
        /**
         * Build call for listReposters
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listRepostersCall(trackId, limit, _callback);
        }


        /**
         * Execute listReposters request
         * @return Users
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public Users execute() throws ApiException {
            ApiResponse<Users> localVarResp = listRepostersWithHttpInfo(trackId, limit);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute listReposters request with HTTP info returned
         * @return ApiResponse&lt;Users&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Users> executeWithHttpInfo() throws ApiException {
            return listRepostersWithHttpInfo(trackId, limit);
        }

        /**
         * Execute listReposters request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Users> _callback) throws ApiException {
            return listRepostersAsync(trackId, limit, _callback);
        }
    }

    /**
     * Returns a collection of track&#39;s reposters.
     * 
     * @param trackId SoundCloud Track id (required)
     * @return ListRepostersRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ListRepostersRequestBuilder listReposters(Integer trackId) throws IllegalArgumentException {
        if (trackId == null) throw new IllegalArgumentException("\"trackId\" is required but got null");
        return new ListRepostersRequestBuilder(trackId);
    }
    private okhttp3.Call updateTrackInformationCall(Integer trackId, TrackMetadataRequest trackMetadataRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = trackMetadataRequest;

        // create path and map variables
        String localVarPath = "/tracks/{track_id}"
            .replace("{" + "track_id" + "}", localVarApiClient.escapeString(trackId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json; charset=utf-8"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json",
            "multipart/form-data",
            "multipart/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "AuthHeader" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateTrackInformationValidateBeforeCall(Integer trackId, TrackMetadataRequest trackMetadataRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'trackId' is set
        if (trackId == null) {
            throw new ApiException("Missing the required parameter 'trackId' when calling updateTrackInformation(Async)");
        }

        return updateTrackInformationCall(trackId, trackMetadataRequest, _callback);

    }


    private ApiResponse<Track> updateTrackInformationWithHttpInfo(Integer trackId, TrackMetadataRequest trackMetadataRequest) throws ApiException {
        okhttp3.Call localVarCall = updateTrackInformationValidateBeforeCall(trackId, trackMetadataRequest, null);
        Type localVarReturnType = new TypeToken<Track>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call updateTrackInformationAsync(Integer trackId, TrackMetadataRequest trackMetadataRequest, final ApiCallback<Track> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateTrackInformationValidateBeforeCall(trackId, trackMetadataRequest, _callback);
        Type localVarReturnType = new TypeToken<Track>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class UpdateTrackInformationRequestBuilder {
        private final Integer trackId;
        private TrackMetadataRequestTrack track;

        private UpdateTrackInformationRequestBuilder(Integer trackId) {
            this.trackId = trackId;
        }

        /**
         * Set track
         * @param track  (optional)
         * @return UpdateTrackInformationRequestBuilder
         */
        public UpdateTrackInformationRequestBuilder track(TrackMetadataRequestTrack track) {
            this.track = track;
            return this;
        }
        
        /**
         * Build call for updateTrackInformation
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            TrackMetadataRequest trackMetadataRequest = buildBodyParams();
            return updateTrackInformationCall(trackId, trackMetadataRequest, _callback);
        }

        private TrackMetadataRequest buildBodyParams() {
            TrackMetadataRequest trackMetadataRequest = new TrackMetadataRequest();
            trackMetadataRequest.track(this.track);
            return trackMetadataRequest;
        }

        /**
         * Execute updateTrackInformation request
         * @return Track
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public Track execute() throws ApiException {
            TrackMetadataRequest trackMetadataRequest = buildBodyParams();
            ApiResponse<Track> localVarResp = updateTrackInformationWithHttpInfo(trackId, trackMetadataRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute updateTrackInformation request with HTTP info returned
         * @return ApiResponse&lt;Track&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Track> executeWithHttpInfo() throws ApiException {
            TrackMetadataRequest trackMetadataRequest = buildBodyParams();
            return updateTrackInformationWithHttpInfo(trackId, trackMetadataRequest);
        }

        /**
         * Execute updateTrackInformation request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Track> _callback) throws ApiException {
            TrackMetadataRequest trackMetadataRequest = buildBodyParams();
            return updateTrackInformationAsync(trackId, trackMetadataRequest, _callback);
        }
    }

    /**
     * Updates a track&#39;s information.
     * 
     * @param trackId SoundCloud Track id (required)
     * @return UpdateTrackInformationRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public UpdateTrackInformationRequestBuilder updateTrackInformation(Integer trackId) throws IllegalArgumentException {
        if (trackId == null) throw new IllegalArgumentException("\"trackId\" is required but got null");
        return new UpdateTrackInformationRequestBuilder(trackId);
    }
    private okhttp3.Call uploadNewTrackCall(String trackTitle, File trackAssetData, String trackPermalink, String trackSharing, String trackEmbeddableBy, String trackPurchaseUrl, String trackDescription, String trackGenre, String trackTagList, String trackLabelName, String trackRelease, String trackReleaseDate, Boolean trackStreamable, Boolean trackDownloadable, String trackLicense, Boolean trackCommentable, String trackIsrc, File trackArtworkData, TracksUploadNewTrackRequest tracksUploadNewTrackRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = tracksUploadNewTrackRequest;

        // create path and map variables
        String localVarPath = "/tracks";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (trackTitle != null) {
            localVarFormParams.put("track[title]", trackTitle);
        }

        if (trackAssetData != null) {
            localVarFormParams.put("track[asset_data]", trackAssetData);
        }

        if (trackPermalink != null) {
            localVarFormParams.put("track[permalink]", trackPermalink);
        }

        if (trackSharing != null) {
            localVarFormParams.put("track[sharing]", trackSharing);
        }

        if (trackEmbeddableBy != null) {
            localVarFormParams.put("track[embeddable_by]", trackEmbeddableBy);
        }

        if (trackPurchaseUrl != null) {
            localVarFormParams.put("track[purchase_url]", trackPurchaseUrl);
        }

        if (trackDescription != null) {
            localVarFormParams.put("track[description]", trackDescription);
        }

        if (trackGenre != null) {
            localVarFormParams.put("track[genre]", trackGenre);
        }

        if (trackTagList != null) {
            localVarFormParams.put("track[tag_list]", trackTagList);
        }

        if (trackLabelName != null) {
            localVarFormParams.put("track[label_name]", trackLabelName);
        }

        if (trackRelease != null) {
            localVarFormParams.put("track[release]", trackRelease);
        }

        if (trackReleaseDate != null) {
            localVarFormParams.put("track[release_date]", trackReleaseDate);
        }

        if (trackStreamable != null) {
            localVarFormParams.put("track[streamable]", trackStreamable);
        }

        if (trackDownloadable != null) {
            localVarFormParams.put("track[downloadable]", trackDownloadable);
        }

        if (trackLicense != null) {
            localVarFormParams.put("track[license]", trackLicense);
        }

        if (trackCommentable != null) {
            localVarFormParams.put("track[commentable]", trackCommentable);
        }

        if (trackIsrc != null) {
            localVarFormParams.put("track[isrc]", trackIsrc);
        }

        if (trackArtworkData != null) {
            localVarFormParams.put("track[artwork_data]", trackArtworkData);
        }

        final String[] localVarAccepts = {
            "application/json; charset=utf-8",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data",
            "multipart/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "AuthHeader" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call uploadNewTrackValidateBeforeCall(String trackTitle, File trackAssetData, String trackPermalink, String trackSharing, String trackEmbeddableBy, String trackPurchaseUrl, String trackDescription, String trackGenre, String trackTagList, String trackLabelName, String trackRelease, String trackReleaseDate, Boolean trackStreamable, Boolean trackDownloadable, String trackLicense, Boolean trackCommentable, String trackIsrc, File trackArtworkData, TracksUploadNewTrackRequest tracksUploadNewTrackRequest, final ApiCallback _callback) throws ApiException {
        return uploadNewTrackCall(trackTitle, trackAssetData, trackPermalink, trackSharing, trackEmbeddableBy, trackPurchaseUrl, trackDescription, trackGenre, trackTagList, trackLabelName, trackRelease, trackReleaseDate, trackStreamable, trackDownloadable, trackLicense, trackCommentable, trackIsrc, trackArtworkData, tracksUploadNewTrackRequest, _callback);

    }


    private ApiResponse<Track> uploadNewTrackWithHttpInfo(String trackTitle, File trackAssetData, String trackPermalink, String trackSharing, String trackEmbeddableBy, String trackPurchaseUrl, String trackDescription, String trackGenre, String trackTagList, String trackLabelName, String trackRelease, String trackReleaseDate, Boolean trackStreamable, Boolean trackDownloadable, String trackLicense, Boolean trackCommentable, String trackIsrc, File trackArtworkData, TracksUploadNewTrackRequest tracksUploadNewTrackRequest) throws ApiException {
        okhttp3.Call localVarCall = uploadNewTrackValidateBeforeCall(trackTitle, trackAssetData, trackPermalink, trackSharing, trackEmbeddableBy, trackPurchaseUrl, trackDescription, trackGenre, trackTagList, trackLabelName, trackRelease, trackReleaseDate, trackStreamable, trackDownloadable, trackLicense, trackCommentable, trackIsrc, trackArtworkData, tracksUploadNewTrackRequest, null);
        Type localVarReturnType = new TypeToken<Track>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call uploadNewTrackAsync(String trackTitle, File trackAssetData, String trackPermalink, String trackSharing, String trackEmbeddableBy, String trackPurchaseUrl, String trackDescription, String trackGenre, String trackTagList, String trackLabelName, String trackRelease, String trackReleaseDate, Boolean trackStreamable, Boolean trackDownloadable, String trackLicense, Boolean trackCommentable, String trackIsrc, File trackArtworkData, TracksUploadNewTrackRequest tracksUploadNewTrackRequest, final ApiCallback<Track> _callback) throws ApiException {

        okhttp3.Call localVarCall = uploadNewTrackValidateBeforeCall(trackTitle, trackAssetData, trackPermalink, trackSharing, trackEmbeddableBy, trackPurchaseUrl, trackDescription, trackGenre, trackTagList, trackLabelName, trackRelease, trackReleaseDate, trackStreamable, trackDownloadable, trackLicense, trackCommentable, trackIsrc, trackArtworkData, tracksUploadNewTrackRequest, _callback);
        Type localVarReturnType = new TypeToken<Track>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class UploadNewTrackRequestBuilder {
        private String trackTitle;
        private File trackAssetData;
        private String trackPermalink;
        private String trackSharing;
        private String trackEmbeddableBy;
        private String trackPurchaseUrl;
        private String trackDescription;
        private String trackGenre;
        private String trackTagList;
        private String trackLabelName;
        private String trackRelease;
        private String trackReleaseDate;
        private Boolean trackStreamable;
        private Boolean trackDownloadable;
        private String trackLicense;
        private Boolean trackCommentable;
        private String trackIsrc;
        private File trackArtworkData;
        private TracksUploadNewTrackRequest tracksUploadNewTrackRequest;

        private UploadNewTrackRequestBuilder() {
        }

        /**
         * Set tracksUploadNewTrackRequest
         * @param tracksUploadNewTrackRequest  (optional)
         * @return UploadNewTrackRequestBuilder
         */
        public UploadNewTrackRequestBuilder tracksUploadNewTrackRequest(TracksUploadNewTrackRequest tracksUploadNewTrackRequest) {
            this.tracksUploadNewTrackRequest = tracksUploadNewTrackRequest;
            return this;
        }

        /**
         * Set trackTitle
         * @param trackTitle  (optional)
         * @return UploadNewTrackRequestBuilder
         */
        public UploadNewTrackRequestBuilder trackTitle(String trackTitle) {
            this.trackTitle = trackTitle;
            return this;
        }
        
        /**
         * Set trackAssetData
         * @param trackAssetData  (optional)
         * @return UploadNewTrackRequestBuilder
         */
        public UploadNewTrackRequestBuilder trackAssetData(File trackAssetData) {
            this.trackAssetData = trackAssetData;
            return this;
        }
        
        /**
         * Set trackPermalink
         * @param trackPermalink  (optional)
         * @return UploadNewTrackRequestBuilder
         */
        public UploadNewTrackRequestBuilder trackPermalink(String trackPermalink) {
            this.trackPermalink = trackPermalink;
            return this;
        }
        
        /**
         * Set trackSharing
         * @param trackSharing  (optional, default to public)
         * @return UploadNewTrackRequestBuilder
         */
        public UploadNewTrackRequestBuilder trackSharing(String trackSharing) {
            this.trackSharing = trackSharing;
            return this;
        }
        
        /**
         * Set trackEmbeddableBy
         * @param trackEmbeddableBy who can embed this track \\\&quot;all\\\&quot;, \\\&quot;me\\\&quot;, or \\\&quot;none\\\&quot; (optional)
         * @return UploadNewTrackRequestBuilder
         */
        public UploadNewTrackRequestBuilder trackEmbeddableBy(String trackEmbeddableBy) {
            this.trackEmbeddableBy = trackEmbeddableBy;
            return this;
        }
        
        /**
         * Set trackPurchaseUrl
         * @param trackPurchaseUrl  (optional)
         * @return UploadNewTrackRequestBuilder
         */
        public UploadNewTrackRequestBuilder trackPurchaseUrl(String trackPurchaseUrl) {
            this.trackPurchaseUrl = trackPurchaseUrl;
            return this;
        }
        
        /**
         * Set trackDescription
         * @param trackDescription  (optional)
         * @return UploadNewTrackRequestBuilder
         */
        public UploadNewTrackRequestBuilder trackDescription(String trackDescription) {
            this.trackDescription = trackDescription;
            return this;
        }
        
        /**
         * Set trackGenre
         * @param trackGenre  (optional)
         * @return UploadNewTrackRequestBuilder
         */
        public UploadNewTrackRequestBuilder trackGenre(String trackGenre) {
            this.trackGenre = trackGenre;
            return this;
        }
        
        /**
         * Set trackTagList
         * @param trackTagList The tag_list property contains a list of tags separated by spaces. Multiword tags are quoted in double quotes. We also support machine tags that follow the pattern NAMESPACE:KEY&#x3D;VALUE. For example: geo:lat&#x3D;43.555 camel:size&#x3D;medium “machine:tag&#x3D;with space” Machine tags are not revealed to the user on the track pages. (optional)
         * @return UploadNewTrackRequestBuilder
         */
        public UploadNewTrackRequestBuilder trackTagList(String trackTagList) {
            this.trackTagList = trackTagList;
            return this;
        }
        
        /**
         * Set trackLabelName
         * @param trackLabelName  (optional)
         * @return UploadNewTrackRequestBuilder
         */
        public UploadNewTrackRequestBuilder trackLabelName(String trackLabelName) {
            this.trackLabelName = trackLabelName;
            return this;
        }
        
        /**
         * Set trackRelease
         * @param trackRelease  (optional)
         * @return UploadNewTrackRequestBuilder
         */
        public UploadNewTrackRequestBuilder trackRelease(String trackRelease) {
            this.trackRelease = trackRelease;
            return this;
        }
        
        /**
         * Set trackReleaseDate
         * @param trackReleaseDate string, formatted as yyyy-mm-dd, representing release date (optional)
         * @return UploadNewTrackRequestBuilder
         */
        public UploadNewTrackRequestBuilder trackReleaseDate(String trackReleaseDate) {
            this.trackReleaseDate = trackReleaseDate;
            return this;
        }
        
        /**
         * Set trackStreamable
         * @param trackStreamable  (optional, default to true)
         * @return UploadNewTrackRequestBuilder
         */
        public UploadNewTrackRequestBuilder trackStreamable(Boolean trackStreamable) {
            this.trackStreamable = trackStreamable;
            return this;
        }
        
        /**
         * Set trackDownloadable
         * @param trackDownloadable  (optional, default to true)
         * @return UploadNewTrackRequestBuilder
         */
        public UploadNewTrackRequestBuilder trackDownloadable(Boolean trackDownloadable) {
            this.trackDownloadable = trackDownloadable;
            return this;
        }
        
        /**
         * Set trackLicense
         * @param trackLicense Possible values: no-rights-reserved, all-rights-reserved, cc-by, cc-by-nc, cc-by-nd, cc-by-sa, cc-by-nc-nd, cc-by-nc-sa (optional)
         * @return UploadNewTrackRequestBuilder
         */
        public UploadNewTrackRequestBuilder trackLicense(String trackLicense) {
            this.trackLicense = trackLicense;
            return this;
        }
        
        /**
         * Set trackCommentable
         * @param trackCommentable  (optional, default to true)
         * @return UploadNewTrackRequestBuilder
         */
        public UploadNewTrackRequestBuilder trackCommentable(Boolean trackCommentable) {
            this.trackCommentable = trackCommentable;
            return this;
        }
        
        /**
         * Set trackIsrc
         * @param trackIsrc  (optional)
         * @return UploadNewTrackRequestBuilder
         */
        public UploadNewTrackRequestBuilder trackIsrc(String trackIsrc) {
            this.trackIsrc = trackIsrc;
            return this;
        }
        
        /**
         * Set trackArtworkData
         * @param trackArtworkData  (optional)
         * @return UploadNewTrackRequestBuilder
         */
        public UploadNewTrackRequestBuilder trackArtworkData(File trackArtworkData) {
            this.trackArtworkData = trackArtworkData;
            return this;
        }
        
        /**
         * Build call for uploadNewTrack
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            TracksUploadNewTrackRequest tracksUploadNewTrackRequest = buildBodyParams();
            return uploadNewTrackCall(trackTitle, trackAssetData, trackPermalink, trackSharing, trackEmbeddableBy, trackPurchaseUrl, trackDescription, trackGenre, trackTagList, trackLabelName, trackRelease, trackReleaseDate, trackStreamable, trackDownloadable, trackLicense, trackCommentable, trackIsrc, trackArtworkData, tracksUploadNewTrackRequest, _callback);
        }

        private TracksUploadNewTrackRequest buildBodyParams() {
            return this.tracksUploadNewTrackRequest;
        }

        /**
         * Execute uploadNewTrack request
         * @return Track
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public Track execute() throws ApiException {
            TracksUploadNewTrackRequest tracksUploadNewTrackRequest = buildBodyParams();
            ApiResponse<Track> localVarResp = uploadNewTrackWithHttpInfo(trackTitle, trackAssetData, trackPermalink, trackSharing, trackEmbeddableBy, trackPurchaseUrl, trackDescription, trackGenre, trackTagList, trackLabelName, trackRelease, trackReleaseDate, trackStreamable, trackDownloadable, trackLicense, trackCommentable, trackIsrc, trackArtworkData, tracksUploadNewTrackRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute uploadNewTrack request with HTTP info returned
         * @return ApiResponse&lt;Track&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Track> executeWithHttpInfo() throws ApiException {
            TracksUploadNewTrackRequest tracksUploadNewTrackRequest = buildBodyParams();
            return uploadNewTrackWithHttpInfo(trackTitle, trackAssetData, trackPermalink, trackSharing, trackEmbeddableBy, trackPurchaseUrl, trackDescription, trackGenre, trackTagList, trackLabelName, trackRelease, trackReleaseDate, trackStreamable, trackDownloadable, trackLicense, trackCommentable, trackIsrc, trackArtworkData, tracksUploadNewTrackRequest);
        }

        /**
         * Execute uploadNewTrack request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Track> _callback) throws ApiException {
            TracksUploadNewTrackRequest tracksUploadNewTrackRequest = buildBodyParams();
            return uploadNewTrackAsync(trackTitle, trackAssetData, trackPermalink, trackSharing, trackEmbeddableBy, trackPurchaseUrl, trackDescription, trackGenre, trackTagList, trackLabelName, trackRelease, trackReleaseDate, trackStreamable, trackDownloadable, trackLicense, trackCommentable, trackIsrc, trackArtworkData, tracksUploadNewTrackRequest, _callback);
        }
    }

    /**
     * Uploads a new track.
     * 
     * @return UploadNewTrackRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public UploadNewTrackRequestBuilder uploadNewTrack() throws IllegalArgumentException {
        return new UploadNewTrackRequestBuilder();
    }
}
